; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

	TITLE	C:\Users\Simon\Documents\Visual Studio 2012\Projects\Stereoscopic\Camera.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
_MoveSpeed DD	042480000r			; 50
_RotSpeed DD	040000000r			; 2
CONST	ENDS
PUBLIC	_tanf
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0D3DXMATRIX@@QAE@XZ				; D3DXMATRIX::D3DXMATRIX
PUBLIC	??DD3DXMATRIX@@QBE?AU0@ABU0@@Z			; D3DXMATRIX::operator*
PUBLIC	??0_D3DXMATRIXA16@@QAE@XZ			; _D3DXMATRIXA16::_D3DXMATRIXA16
PUBLIC	??4_D3DXMATRIXA16@@QAEAAU0@ABUD3DXMATRIX@@@Z	; _D3DXMATRIXA16::operator=
PUBLIC	??0CCamera@@QAE@UD3DXVECTOR3@@0MMM@Z		; CCamera::CCamera
PUBLIC	?GetPosition@CCamera@@QAE?AUD3DXVECTOR3@@W4EStereoscopic@@M@Z ; CCamera::GetPosition
PUBLIC	?GetViewMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@W4EStereoscopic@@M@Z ; CCamera::GetViewMatrix
PUBLIC	?GetProjectionMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@W4EStereoscopic@@MM@Z ; CCamera::GetProjectionMatrix
PUBLIC	?SetFOV@CCamera@@QAEXM@Z			; CCamera::SetFOV
PUBLIC	?SetNearClip@CCamera@@QAEXM@Z			; CCamera::SetNearClip
PUBLIC	?SetFarClip@CCamera@@QAEXM@Z			; CCamera::SetFarClip
PUBLIC	?UpdateMatrices@CCamera@@QAEXXZ			; CCamera::UpdateMatrices
PUBLIC	?Control@CCamera@@QAEXMW4EKeyCode@@0000000@Z	; CCamera::Control
PUBLIC	__real@3f000000
PUBLIC	__real@3faa9fbe
PUBLIC	__real@40000000
PUBLIC	__real@bf000000
EXTRN	_memcpy:PROC
EXTRN	_tan:PROC
EXTRN	_D3DXMatrixMultiply@12:PROC
EXTRN	_D3DXMatrixInverse@12:PROC
EXTRN	_D3DXMatrixTranslation@16:PROC
EXTRN	_D3DXMatrixRotationX@8:PROC
EXTRN	_D3DXMatrixRotationY@8:PROC
EXTRN	_D3DXMatrixRotationZ@8:PROC
EXTRN	_D3DXMatrixPerspectiveFovLH@20:PROC
EXTRN	?KeyHeld@@YA_NW4EKeyCode@@@Z:PROC		; KeyHeld
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	?g_ViewportWidth@@3HA:DWORD			; g_ViewportWidth
EXTRN	?g_ViewportHeight@@3HA:DWORD			; g_ViewportHeight
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3faa9fbe
CONST	SEGMENT
__real@3faa9fbe DD 03faa9fber			; 1.333
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\visual studio 2012\projects\stereoscopic\camera.cpp
;	COMDAT ?Control@CCamera@@QAEXMW4EKeyCode@@0000000@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_frameTime$ = 8						; size = 4
_turnUp$ = 12						; size = 4
_turnDown$ = 16						; size = 4
_turnLeft$ = 20						; size = 4
_turnRight$ = 24					; size = 4
_moveForward$ = 28					; size = 4
_moveBackward$ = 32					; size = 4
_moveLeft$ = 36						; size = 4
_moveRight$ = 40					; size = 4
?Control@CCamera@@QAEXMW4EKeyCode@@0000000@Z PROC	; CCamera::Control, COMDAT
; _this$ = ecx

; 121  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 	if (KeyHeld( turnDown ))

	mov	eax, DWORD PTR _turnDown$[ebp]
	push	eax
	call	?KeyHeld@@YA_NW4EKeyCode@@@Z		; KeyHeld
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@Control

; 123  : 	{
; 124  : 		m_Rotation.x += RotSpeed * frameTime;

	movss	xmm0, DWORD PTR _RotSpeed
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+12], xmm0
$LN8@Control:

; 125  : 	}
; 126  : 	if (KeyHeld( turnUp ))

	mov	eax, DWORD PTR _turnUp$[ebp]
	push	eax
	call	?KeyHeld@@YA_NW4EKeyCode@@@Z		; KeyHeld
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@Control

; 127  : 	{
; 128  : 		m_Rotation.x -= RotSpeed * frameTime;

	movss	xmm0, DWORD PTR _RotSpeed
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+12]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+12], xmm1
$LN7@Control:

; 129  : 	}
; 130  : 	if (KeyHeld( turnRight ))

	mov	eax, DWORD PTR _turnRight$[ebp]
	push	eax
	call	?KeyHeld@@YA_NW4EKeyCode@@@Z		; KeyHeld
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@Control

; 131  : 	{
; 132  : 		m_Rotation.y += RotSpeed * frameTime;

	movss	xmm0, DWORD PTR _RotSpeed
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+16], xmm0
$LN6@Control:

; 133  : 	}
; 134  : 	if (KeyHeld( turnLeft ))

	mov	eax, DWORD PTR _turnLeft$[ebp]
	push	eax
	call	?KeyHeld@@YA_NW4EKeyCode@@@Z		; KeyHeld
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@Control

; 135  : 	{
; 136  : 		m_Rotation.y -= RotSpeed * frameTime;

	movss	xmm0, DWORD PTR _RotSpeed
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+16]
	subss	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+16], xmm1
$LN5@Control:

; 137  : 	}
; 138  : 
; 139  : 	// Local X movement - move in the direction of the X axis, get axis from camera's "world" matrix
; 140  : 	if (KeyHeld( moveRight ))

	mov	eax, DWORD PTR _moveRight$[ebp]
	push	eax
	call	?KeyHeld@@YA_NW4EKeyCode@@@Z		; KeyHeld
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@Control

; 141  : 	{
; 142  : 		m_Position.x += m_WorldMatrix._11 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	mulss	xmm0, DWORD PTR _MoveSpeed
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx], xmm0

; 143  : 		m_Position.y += m_WorldMatrix._12 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+52]
	mulss	xmm0, DWORD PTR _MoveSpeed
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+4], xmm0

; 144  : 		m_Position.z += m_WorldMatrix._13 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	mulss	xmm0, DWORD PTR _MoveSpeed
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+8], xmm0
$LN4@Control:

; 145  : 	}
; 146  : 	if (KeyHeld( moveLeft ))

	mov	eax, DWORD PTR _moveLeft$[ebp]
	push	eax
	call	?KeyHeld@@YA_NW4EKeyCode@@@Z		; KeyHeld
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@Control

; 147  : 	{
; 148  : 		m_Position.x -= m_WorldMatrix._11 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	mulss	xmm0, DWORD PTR _MoveSpeed
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx], xmm1

; 149  : 		m_Position.y -= m_WorldMatrix._12 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+52]
	mulss	xmm0, DWORD PTR _MoveSpeed
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+4]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+4], xmm1

; 150  : 		m_Position.z -= m_WorldMatrix._13 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	mulss	xmm0, DWORD PTR _MoveSpeed
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+8], xmm1
$LN3@Control:

; 151  : 	}
; 152  : 
; 153  : 	// Local Z movement - move in the direction of the Z axis, get axis from view matrix
; 154  : 	if (KeyHeld( moveForward ))

	mov	eax, DWORD PTR _moveForward$[ebp]
	push	eax
	call	?KeyHeld@@YA_NW4EKeyCode@@@Z		; KeyHeld
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Control

; 155  : 	{
; 156  : 		m_Position.x += m_WorldMatrix._31 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+80]
	mulss	xmm0, DWORD PTR _MoveSpeed
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx], xmm0

; 157  : 		m_Position.y += m_WorldMatrix._32 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+84]
	mulss	xmm0, DWORD PTR _MoveSpeed
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+4], xmm0

; 158  : 		m_Position.z += m_WorldMatrix._33 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+88]
	mulss	xmm0, DWORD PTR _MoveSpeed
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	addss	xmm0, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+8], xmm0
$LN2@Control:

; 159  : 	}
; 160  : 	if (KeyHeld( moveBackward ))

	mov	eax, DWORD PTR _moveBackward$[ebp]
	push	eax
	call	?KeyHeld@@YA_NW4EKeyCode@@@Z		; KeyHeld
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Control

; 161  : 	{
; 162  : 		m_Position.x -= m_WorldMatrix._31 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+80]
	mulss	xmm0, DWORD PTR _MoveSpeed
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx], xmm1

; 163  : 		m_Position.y -= m_WorldMatrix._32 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+84]
	mulss	xmm0, DWORD PTR _MoveSpeed
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+4]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+4], xmm1

; 164  : 		m_Position.z -= m_WorldMatrix._33 * MoveSpeed * frameTime;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+88]
	mulss	xmm0, DWORD PTR _MoveSpeed
	mulss	xmm0, DWORD PTR _frameTime$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	subss	xmm1, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+8], xmm1
$LN1@Control:

; 165  : 	}
; 166  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?Control@CCamera@@QAEXMW4EKeyCode@@0000000@Z ENDP	; CCamera::Control
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\visual studio 2012\projects\stereoscopic\camera.cpp
;	COMDAT ?UpdateMatrices@CCamera@@QAEXXZ
_TEXT	SEGMENT
$T1 = -832						; size = 64
$T2 = -760						; size = 64
$T3 = -688						; size = 64
$T4 = -616						; size = 64
_aspect$ = -348						; size = 4
_matrixTranslation$ = -336				; size = 64
_matrixZRot$ = -256					; size = 64
_matrixYRot$ = -176					; size = 64
_matrixXRot$ = -96					; size = 64
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?UpdateMatrices@CCamera@@QAEXXZ PROC			; CCamera::UpdateMatrices, COMDAT
; _this$ = ecx

; 35   : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 840				; 00000348H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-840]
	mov	ecx, 210				; 000000d2H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 36   : 	// Make matrices for position and rotations, then multiply together to get a "camera world matrix"
; 37   : 	D3DXMATRIXA16 matrixXRot, matrixYRot, matrixZRot, matrixTranslation;

	lea	ecx, DWORD PTR _matrixXRot$[ebp]
	call	??0_D3DXMATRIXA16@@QAE@XZ		; _D3DXMATRIXA16::_D3DXMATRIXA16
	lea	ecx, DWORD PTR _matrixYRot$[ebp]
	call	??0_D3DXMATRIXA16@@QAE@XZ		; _D3DXMATRIXA16::_D3DXMATRIXA16
	lea	ecx, DWORD PTR _matrixZRot$[ebp]
	call	??0_D3DXMATRIXA16@@QAE@XZ		; _D3DXMATRIXA16::_D3DXMATRIXA16
	lea	ecx, DWORD PTR _matrixTranslation$[ebp]
	call	??0_D3DXMATRIXA16@@QAE@XZ		; _D3DXMATRIXA16::_D3DXMATRIXA16

; 38   : 	D3DXMatrixRotationX( &matrixXRot, m_Rotation.x );

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _matrixXRot$[ebp]
	push	ecx
	call	_D3DXMatrixRotationX@8

; 39   : 	D3DXMatrixRotationY( &matrixYRot, m_Rotation.y );

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+16]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _matrixYRot$[ebp]
	push	ecx
	call	_D3DXMatrixRotationY@8

; 40   : 	D3DXMatrixRotationZ( &matrixZRot, m_Rotation.z );

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+20]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _matrixZRot$[ebp]
	push	ecx
	call	_D3DXMatrixRotationZ@8

; 41   : 	D3DXMatrixTranslation( &matrixTranslation, m_Position.x, m_Position.y, m_Position.z);

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _matrixTranslation$[ebp]
	push	eax
	call	_D3DXMatrixTranslation@16

; 42   : 	m_WorldMatrix = matrixZRot * matrixXRot * matrixYRot * matrixTranslation;

	lea	eax, DWORD PTR _matrixTranslation$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	edx, DWORD PTR _matrixYRot$[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _matrixXRot$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	ecx, DWORD PTR _matrixZRot$[ebp]
	call	??DD3DXMATRIX@@QBE?AU0@ABU0@@Z		; D3DXMATRIX::operator*
	mov	ecx, eax
	call	??DD3DXMATRIX@@QBE?AU0@ABU0@@Z		; D3DXMATRIX::operator*
	mov	ecx, eax
	call	??DD3DXMATRIX@@QBE?AU0@ABU0@@Z		; D3DXMATRIX::operator*
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4_D3DXMATRIXA16@@QAEAAU0@ABUD3DXMATRIX@@@Z ; _D3DXMATRIXA16::operator=

; 43   : 
; 44   : 	// The rendering pipeline actually needs the inverse of the camera world matrix - called the view matrix. Creating an inverse is easy with DirectX:
; 45   : 	D3DXMatrixInverse( &m_ViewMatrix, NULL, &m_WorldMatrix );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	push	ecx
	call	_D3DXMatrixInverse@12

; 46   : 
; 47   : 	// Initialize the projection matrix. This determines viewing properties of the camera such as field of view (FOV) and near clip distance
; 48   : 	// One other factor in the projection matrix is the aspect ratio of screen (width/height) - used to adjust FOV between horizontal and vertical
; 49   : 	float aspect = (float)g_ViewportWidth / g_ViewportHeight; 

	cvtsi2ss xmm0, DWORD PTR ?g_ViewportWidth@@3HA	; g_ViewportWidth
	cvtsi2ss xmm1, DWORD PTR ?g_ViewportHeight@@3HA	; g_ViewportHeight
	divss	xmm0, xmm1
	movss	DWORD PTR _aspect$[ebp], xmm0

; 50   : 	D3DXMatrixPerspectiveFovLH( &m_ProjMatrix, m_FOV, m_Aspect, m_NearClip, m_FarClip );

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+36]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+32]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+28]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+24]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	push	ecx
	call	_D3DXMatrixPerspectiveFovLH@20

; 51   : 
; 52   : 	// Combine the view and projection matrix into a single matrix - which can (optionally) be used in the vertex shaders to save one matrix multiply per vertex
; 53   : 	m_ViewProjMatrix = m_ViewMatrix * m_ProjMatrix;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 176				; 000000b0H
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??DD3DXMATRIX@@QBE?AU0@ABU0@@Z		; D3DXMATRIX::operator*
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 240				; 000000f0H
	call	??4_D3DXMATRIXA16@@QAEAAU0@ABUD3DXMATRIX@@@Z ; _D3DXMATRIXA16::operator=

; 54   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@UpdateMatr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
	npad	2
$LN8@UpdateMatr:
	DD	4
	DD	$LN7@UpdateMatr
$LN7@UpdateMatr:
	DD	-96					; ffffffa0H
	DD	64					; 00000040H
	DD	$LN3@UpdateMatr
	DD	-176					; ffffff50H
	DD	64					; 00000040H
	DD	$LN4@UpdateMatr
	DD	-256					; ffffff00H
	DD	64					; 00000040H
	DD	$LN5@UpdateMatr
	DD	-336					; fffffeb0H
	DD	64					; 00000040H
	DD	$LN6@UpdateMatr
$LN6@UpdateMatr:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	84					; 00000054H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
$LN5@UpdateMatr:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	90					; 0000005aH
	DB	82					; 00000052H
	DB	111					; 0000006fH
	DB	116					; 00000074H
	DB	0
$LN4@UpdateMatr:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	89					; 00000059H
	DB	82					; 00000052H
	DB	111					; 0000006fH
	DB	116					; 00000074H
	DB	0
$LN3@UpdateMatr:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	88					; 00000058H
	DB	82					; 00000052H
	DB	111					; 0000006fH
	DB	116					; 00000074H
	DB	0
?UpdateMatrices@CCamera@@QAEXXZ ENDP			; CCamera::UpdateMatrices
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\visual studio 2012\projects\stereoscopic\camera.h
;	COMDAT ?SetFarClip@CCamera@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_farClip$ = 8						; size = 4
?SetFarClip@CCamera@@QAEXM@Z PROC			; CCamera::SetFarClip, COMDAT
; _this$ = ecx

; 114  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 115  : 		m_FarClip = farClip;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _farClip$[ebp]
	movss	DWORD PTR [eax+36], xmm0

; 116  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFarClip@CCamera@@QAEXM@Z ENDP			; CCamera::SetFarClip
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\visual studio 2012\projects\stereoscopic\camera.h
;	COMDAT ?SetNearClip@CCamera@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nearClip$ = 8						; size = 4
?SetNearClip@CCamera@@QAEXM@Z PROC			; CCamera::SetNearClip, COMDAT
; _this$ = ecx

; 110  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 111  : 		m_NearClip = nearClip;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _nearClip$[ebp]
	movss	DWORD PTR [eax+32], xmm0

; 112  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetNearClip@CCamera@@QAEXM@Z ENDP			; CCamera::SetNearClip
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\visual studio 2012\projects\stereoscopic\camera.h
;	COMDAT ?SetFOV@CCamera@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_fov$ = 8						; size = 4
?SetFOV@CCamera@@QAEXM@Z PROC				; CCamera::SetFOV, COMDAT
; _this$ = ecx

; 106  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 107  : 		m_FOV = fov;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fov$[ebp]
	movss	DWORD PTR [eax+24], xmm0

; 108  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFOV@CCamera@@QAEXM@Z ENDP				; CCamera::SetFOV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\visual studio 2012\projects\stereoscopic\camera.cpp
;	COMDAT ?GetProjectionMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@W4EStereoscopic@@MM@Z
_TEXT	SEGMENT
tv139 = -300						; size = 4
tv148 = -296						; size = 4
tv68 = -296						; size = 4
_projMatrix$ = -96					; size = 64
_offset$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_stereo$ = 12						; size = 4
_interocular$ = 16					; size = 4
_screenDistance$ = 20					; size = 4
?GetProjectionMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@W4EStereoscopic@@MM@Z PROC ; CCamera::GetProjectionMatrix, COMDAT
; _this$ = ecx

; 101  : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 312				; 00000138H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-312]
	mov	ecx, 78					; 0000004eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 102  : 	// Not stereoscopic
; 103  : 	if (stereo == Monoscopic) return m_ProjMatrix;

	cmp	DWORD PTR _stereo$[ebx], 0
	jne	SHORT $LN1@GetProject
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 176				; 000000b0H
	mov	ecx, 16					; 00000010H
	mov	edi, DWORD PTR ___$ReturnUdt$[ebx]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebx]
	jmp	$LN2@GetProject
$LN1@GetProject:

; 104  : 
; 105  : 	// Offset camera by half interocular distance left or right as appropriate
; 106  : 	float offset = interocular * (stereo == StereoscopicLeft ? 0.5f :- 0.5f);

	cmp	DWORD PTR _stereo$[ebx], 1
	jne	SHORT $LN4@GetProject
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv68[ebp], xmm0
	jmp	SHORT $LN5@GetProject
$LN4@GetProject:
	movss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR tv68[ebp], xmm0
$LN5@GetProject:
	movss	xmm0, DWORD PTR _interocular$[ebx]
	mulss	xmm0, DWORD PTR tv68[ebp]
	movss	DWORD PTR _offset$[ebp], xmm0

; 107  : 
; 108  : 	// Offset viewing frustum based on camera offset (as discussed in lecture)
; 109  : 	D3DXMATRIXA16 projMatrix = m_ProjMatrix;

	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 176				; 000000b0H
	mov	ecx, 16					; 00000010H
	lea	edi, DWORD PTR _projMatrix$[ebp]
	rep movsd

; 110  : 	//** MISSING - set the single value in the projection matrix that is different for offset cameras - see the lecture notes
; 111  : 	projMatrix._31 = (offset / screenDistance) / (m_Aspect * tanf(m_FOV/2));

	movss	xmm0, DWORD PTR _offset$[ebp]
	divss	xmm0, DWORD PTR _screenDistance$[ebx]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm1, DWORD PTR [eax+24]
	divss	xmm1, DWORD PTR __real@40000000
	push	ecx
	movss	DWORD PTR [esp], xmm1
	movss	DWORD PTR tv148[ebp], xmm0
	call	_tanf
	add	esp, 4
	fstp	DWORD PTR tv139[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv139[ebp]
	mulss	xmm0, DWORD PTR [ecx+28]
	movss	xmm1, DWORD PTR tv148[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _projMatrix$[ebp+32], xmm1

; 112  : 	return projMatrix;

	mov	ecx, 16					; 00000010H
	lea	esi, DWORD PTR _projMatrix$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebx]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebx]
$LN2@GetProject:

; 113  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@GetProject
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	16					; 00000010H
	npad	2
$LN8@GetProject:
	DD	1
	DD	$LN7@GetProject
$LN7@GetProject:
	DD	-96					; ffffffa0H
	DD	64					; 00000040H
	DD	$LN6@GetProject
$LN6@GetProject:
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	106					; 0000006aH
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	0
?GetProjectionMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@W4EStereoscopic@@MM@Z ENDP ; CCamera::GetProjectionMatrix
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\visual studio 2012\projects\stereoscopic\camera.cpp
;	COMDAT ?GetViewMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@W4EStereoscopic@@M@Z
_TEXT	SEGMENT
tv68 = -376						; size = 4
_worldMatrix$ = -176					; size = 64
_viewMatrix$ = -96					; size = 64
_offset$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_stereo$ = 12						; size = 4
_interocular$ = 16					; size = 4
?GetViewMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@W4EStereoscopic@@M@Z PROC ; CCamera::GetViewMatrix, COMDAT
; _this$ = ecx

; 78   : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 376				; 00000178H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-376]
	mov	ecx, 94					; 0000005eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 79   : 	// Not stereoscopic
; 80   : 	if (stereo == Monoscopic) return m_ViewMatrix;

	cmp	DWORD PTR _stereo$[ebx], 0
	jne	SHORT $LN1@GetViewMat
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 112				; 00000070H
	mov	ecx, 16					; 00000010H
	mov	edi, DWORD PTR ___$ReturnUdt$[ebx]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebx]
	jmp	$LN2@GetViewMat
$LN1@GetViewMat:

; 81   : 
; 82   : 	// Offset camera by half interocular distance left or right as appropriate
; 83   : 	float offset = interocular * (stereo == StereoscopicLeft ? 0.5f : -0.5f);

	cmp	DWORD PTR _stereo$[ebx], 1
	jne	SHORT $LN4@GetViewMat
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv68[ebp], xmm0
	jmp	SHORT $LN5@GetViewMat
$LN4@GetViewMat:
	movss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR tv68[ebp], xmm0
$LN5@GetViewMat:
	movss	xmm0, DWORD PTR _interocular$[ebx]
	mulss	xmm0, DWORD PTR tv68[ebp]
	movss	DWORD PTR _offset$[ebp], xmm0

; 84   : 
; 85   : 	D3DXMATRIXA16 viewMatrix;

	lea	ecx, DWORD PTR _viewMatrix$[ebp]
	call	??0_D3DXMATRIXA16@@QAE@XZ		; _D3DXMATRIXA16::_D3DXMATRIXA16

; 86   : 	D3DXMATRIXA16 worldMatrix = m_WorldMatrix;

	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 48					; 00000030H
	mov	ecx, 16					; 00000010H
	lea	edi, DWORD PTR _worldMatrix$[ebp]
	rep movsd

; 87   : 	
; 88   : 	worldMatrix._41 += offset * worldMatrix._11;

	movss	xmm0, DWORD PTR _offset$[ebp]
	mulss	xmm0, DWORD PTR _worldMatrix$[ebp]
	addss	xmm0, DWORD PTR _worldMatrix$[ebp+48]
	movss	DWORD PTR _worldMatrix$[ebp+48], xmm0

; 89   : 	worldMatrix._42 += offset * worldMatrix._12;

	movss	xmm0, DWORD PTR _offset$[ebp]
	mulss	xmm0, DWORD PTR _worldMatrix$[ebp+4]
	addss	xmm0, DWORD PTR _worldMatrix$[ebp+52]
	movss	DWORD PTR _worldMatrix$[ebp+52], xmm0

; 90   : 	worldMatrix._43 += offset * worldMatrix._13;

	movss	xmm0, DWORD PTR _offset$[ebp]
	mulss	xmm0, DWORD PTR _worldMatrix$[ebp+8]
	addss	xmm0, DWORD PTR _worldMatrix$[ebp+56]
	movss	DWORD PTR _worldMatrix$[ebp+56], xmm0

; 91   : 	//** MISSING shift the x position in the camera's worldMatrix by the offset calculated above
; 92   : 	// Needs to move in the local x-axis - the function above offers guidance
; 93   : 
; 94   : 	// Invert camera's adjusted "world matrix" to create view matrix
; 95   : 	D3DXMatrixInverse( &viewMatrix, NULL, &worldMatrix );

	lea	eax, DWORD PTR _worldMatrix$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _viewMatrix$[ebp]
	push	ecx
	call	_D3DXMatrixInverse@12

; 96   : 	return viewMatrix;

	mov	ecx, 16					; 00000010H
	lea	esi, DWORD PTR _viewMatrix$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebx]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebx]
$LN2@GetViewMat:

; 97   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@GetViewMat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	12					; 0000000cH
	npad	1
$LN9@GetViewMat:
	DD	2
	DD	$LN8@GetViewMat
$LN8@GetViewMat:
	DD	-96					; ffffffa0H
	DD	64					; 00000040H
	DD	$LN6@GetViewMat
	DD	-176					; ffffff50H
	DD	64					; 00000040H
	DD	$LN7@GetViewMat
$LN7@GetViewMat:
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	108					; 0000006cH
	DB	100					; 00000064H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	0
$LN6@GetViewMat:
	DB	118					; 00000076H
	DB	105					; 00000069H
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	120					; 00000078H
	DB	0
?GetViewMatrix@CCamera@@QAE?AU_D3DXMATRIXA16@@W4EStereoscopic@@M@Z ENDP ; CCamera::GetViewMatrix
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\visual studio 2012\projects\stereoscopic\camera.cpp
;	COMDAT ?GetPosition@CCamera@@QAE?AUD3DXVECTOR3@@W4EStereoscopic@@M@Z
_TEXT	SEGMENT
tv68 = -244						; size = 4
_position$ = -44					; size = 12
_offset$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_stereo$ = 12						; size = 4
_interocular$ = 16					; size = 4
?GetPosition@CCamera@@QAE?AUD3DXVECTOR3@@W4EStereoscopic@@M@Z PROC ; CCamera::GetPosition, COMDAT
; _this$ = ecx

; 62   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 	if (stereo == Monoscopic) return m_Position;

	cmp	DWORD PTR _stereo$[ebp], 0
	jne	SHORT $LN1@GetPositio
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN2@GetPositio
$LN1@GetPositio:

; 64   : 
; 65   : 	// Offset camera by half interocular distance left or right as appropriate
; 66   : 	float offset = interocular * (stereo == StereoscopicLeft ? 0.5f : -0.5f);

	cmp	DWORD PTR _stereo$[ebp], 1
	jne	SHORT $LN4@GetPositio
	movss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR tv68[ebp], xmm0
	jmp	SHORT $LN5@GetPositio
$LN4@GetPositio:
	movss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR tv68[ebp], xmm0
$LN5@GetPositio:
	movss	xmm0, DWORD PTR _interocular$[ebp]
	mulss	xmm0, DWORD PTR tv68[ebp]
	movss	DWORD PTR _offset$[ebp], xmm0

; 67   : 	
; 68   : 	D3DXVECTOR3 position = m_Position;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _position$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _position$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _position$[ebp+8], eax

; 69   : 	position.x += m_WorldMatrix._11 * offset;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+48]
	mulss	xmm0, DWORD PTR _offset$[ebp]
	addss	xmm0, DWORD PTR _position$[ebp]
	movss	DWORD PTR _position$[ebp], xmm0

; 70   : 	position.y += m_WorldMatrix._12 * offset;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+52]
	mulss	xmm0, DWORD PTR _offset$[ebp]
	addss	xmm0, DWORD PTR _position$[ebp+4]
	movss	DWORD PTR _position$[ebp+4], xmm0

; 71   : 	position.z += m_WorldMatrix._13 * offset;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+56]
	mulss	xmm0, DWORD PTR _offset$[ebp]
	addss	xmm0, DWORD PTR _position$[ebp+8]
	movss	DWORD PTR _position$[ebp+8], xmm0

; 72   : 
; 73   : 	return position;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _position$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _position$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN2@GetPositio:

; 74   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@GetPositio
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	1
$LN8@GetPositio:
	DD	1
	DD	$LN7@GetPositio
$LN7@GetPositio:
	DD	-44					; ffffffd4H
	DD	12					; 0000000cH
	DD	$LN6@GetPositio
$LN6@GetPositio:
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
?GetPosition@CCamera@@QAE?AUD3DXVECTOR3@@W4EStereoscopic@@M@Z ENDP ; CCamera::GetPosition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\simon\documents\visual studio 2012\projects\stereoscopic\camera.cpp
;	COMDAT ??0CCamera@@QAE@UD3DXVECTOR3@@0MMM@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 12
_rotation$ = 20						; size = 12
_fov$ = 32						; size = 4
_nearClip$ = 36						; size = 4
_farClip$ = 40						; size = 4
??0CCamera@@QAE@UD3DXVECTOR3@@0MMM@Z PROC		; CCamera::CCamera, COMDAT
; _this$ = ecx

; 15   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0D3DXVECTOR3@@QAE@XZ			; D3DXVECTOR3::D3DXVECTOR3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0D3DXVECTOR3@@QAE@XZ			; D3DXVECTOR3::D3DXVECTOR3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??0_D3DXMATRIXA16@@QAE@XZ		; _D3DXMATRIXA16::_D3DXMATRIXA16
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0_D3DXMATRIXA16@@QAE@XZ		; _D3DXMATRIXA16::_D3DXMATRIXA16
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	call	??0_D3DXMATRIXA16@@QAE@XZ		; _D3DXMATRIXA16::_D3DXMATRIXA16
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 240				; 000000f0H
	call	??0_D3DXMATRIXA16@@QAE@XZ		; _D3DXMATRIXA16::_D3DXMATRIXA16

; 16   : 	m_Position = position;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _position$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _position$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 17   : 	m_Rotation = rotation;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _rotation$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _rotation$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _rotation$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 18   : 	m_Aspect = 1.333f; // Shouldn't be hard-coded (viewport width / viewport height)

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3faa9fbe
	movss	DWORD PTR [eax+28], xmm0

; 19   : 
; 20   : 	SetFOV( fov );

	push	ecx
	movss	xmm0, DWORD PTR _fov$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFOV@CCamera@@QAEXM@Z		; CCamera::SetFOV

; 21   : 	SetNearClip( nearClip );

	push	ecx
	movss	xmm0, DWORD PTR _nearClip$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetNearClip@CCamera@@QAEXM@Z		; CCamera::SetNearClip

; 22   : 	SetFarClip( farClip );

	push	ecx
	movss	xmm0, DWORD PTR _farClip$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFarClip@CCamera@@QAEXM@Z		; CCamera::SetFarClip

; 23   : 
; 24   : 	UpdateMatrices();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateMatrices@CCamera@@QAEXXZ		; CCamera::UpdateMatrices

; 25   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
??0CCamera@@QAE@UD3DXVECTOR3@@0MMM@Z ENDP		; CCamera::CCamera
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
;	COMDAT ??4_D3DXMATRIXA16@@QAEAAU0@ABUD3DXMATRIX@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_rhs$ = 8						; size = 4
??4_D3DXMATRIXA16@@QAEAAU0@ABUD3DXMATRIX@@@Z PROC	; _D3DXMATRIXA16::operator=, COMDAT
; _this$ = ecx

; 1056 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1057 :     memcpy(&_11, &rhs, sizeof(D3DXMATRIX));

	push	64					; 00000040H
	mov	eax, DWORD PTR _rhs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1058 :     return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1059 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4_D3DXMATRIXA16@@QAEAAU0@ABUD3DXMATRIX@@@Z ENDP	; _D3DXMATRIXA16::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.h
;	COMDAT ??0_D3DXMATRIXA16@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_D3DXMATRIXA16@@QAE@XZ PROC				; _D3DXMATRIXA16::_D3DXMATRIXA16, COMDAT
; _this$ = ecx

; 415  :     _D3DXMATRIXA16() {};

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0D3DXMATRIX@@QAE@XZ			; D3DXMATRIX::D3DXMATRIX
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_D3DXMATRIXA16@@QAE@XZ ENDP				; _D3DXMATRIXA16::_D3DXMATRIXA16
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.inl
;	COMDAT ??DD3DXMATRIX@@QBE?AU0@ABU0@@Z
_TEXT	SEGMENT
_matT$ = -84						; size = 64
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_mat$ = 12						; size = 4
??DD3DXMATRIX@@QBE?AU0@ABU0@@Z PROC			; D3DXMATRIX::operator*, COMDAT
; _this$ = ecx

; 896  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 280				; 00000118H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 70					; 00000046H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 897  :     D3DXMATRIX matT;

	lea	ecx, DWORD PTR _matT$[ebp]
	call	??0D3DXMATRIX@@QAE@XZ			; D3DXMATRIX::D3DXMATRIX

; 898  :     D3DXMatrixMultiply(&matT, this, &mat);

	mov	eax, DWORD PTR _mat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR _matT$[ebp]
	push	edx
	call	_D3DXMatrixMultiply@12

; 899  :     return matT;

	mov	ecx, 16					; 00000010H
	lea	esi, DWORD PTR _matT$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 900  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 280				; 00000118H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN5@operator:
	DD	1
	DD	$LN4@operator
$LN4@operator:
	DD	-84					; ffffffacH
	DD	64					; 00000040H
	DD	$LN3@operator
$LN3@operator:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	84					; 00000054H
	DB	0
??DD3DXMATRIX@@QBE?AU0@ABU0@@Z ENDP			; D3DXMATRIX::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.h
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0D3DXMATRIX@@QAE@XZ PROC				; D3DXMATRIX::D3DXMATRIX, COMDAT
; _this$ = ecx

; 348  :     D3DXMATRIX() {};

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0D3DXMATRIX@@QAE@XZ ENDP				; D3DXMATRIX::D3DXMATRIX
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft directx sdk (june 2010)\include\d3dx10math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 198  :     D3DXVECTOR3() {};

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _tanf
_TEXT	SEGMENT
tv76 = -204						; size = 4
tv74 = -200						; size = 8
__X$ = 8						; size = 4
_tanf	PROC						; COMDAT

; 436  :         {return ((float)tan((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_tan
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_tanf	ENDP
_TEXT	ENDS
END
